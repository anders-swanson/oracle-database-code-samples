# Transactional Messaging

In this section, we'll implement transactional messaging using our consumer - for each message consumed, we'll use the consumer's database connection to insert OSON into a JSON Relational Duality View. This demonstrates both consuming events and running database operations in the same transaction, a feature that's unique to Oracle Database Transactional Event Queues.

### Creating the database resources

Because we'll be inserting OSON into a JSON Relational Duality View, we need to run some DDL against our database. The following tables define weather stations and their related weather events.

```sql
CREATE TABLE weather_station (
    id                NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    station_name      VARCHAR2(100) NOT NULL,
    location_lat      NUMBER(9,6), -- latitude
    location_lon      NUMBER(9,6), -- longitude
    elevation_m       NUMBER(6,2)
);

CREATE TABLE weather_event (
    id                NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    station_id        NUMBER NOT NULL,
    timestamp         TIMESTAMP DEFAULT SYSTIMESTAMP,
    temperature       NUMBER(5,2),
    humidity_percent  NUMBER(5,2),
    uv_index          NUMBER(3,1),
    CONSTRAINT fk_weather_station
    FOREIGN KEY (station_id)
    REFERENCES weather_station (id)
    ON DELETE CASCADE
);
```

Next, let's insert a few example weather stations for our app. These stations will are used by our sample events. I picked a few of my favorite mountains in Oregon to serve as example stations.

```sql
INSERT INTO weather_station (station_name, location_lat, location_lon, elevation_m)
VALUES ('Mt. Hood', 45.373611, -121.695833, 3426.00);

INSERT INTO weather_station (station_name, location_lat, location_lon, elevation_m)
VALUES ('South Sister', 44.103889, -121.768056, 3157.00);

INSERT INTO weather_station (station_name, location_lat, location_lon, elevation_m)
VALUES ('Steens Mountain', 42.647500, -118.596389, 2965.00);
```

#### View all weather stations

```sql
select * from weather_station;
```

We then create a JSON Relational Duality View for our weather station and events. This view allows us to read and write weather events using a single round-trip, with our optimized OSON format. The database server in turn handles the processing of JSON and reads/inserts to the `weather_station` and `weather_event` tables.

```sql
CREATE OR REPLACE FORCE EDITIONABLE JSON RELATIONAL DUALITY VIEW weather_event_dv
 AS 
weather_event @insert {
    _id : id
    timestamp
    temperature
    humidityPercent : humidity_percent
    uvIndex : uv_index
    station: weather_station @insert
             @link (from : [STATION_ID]) {
        id
        name : station_name
    }
};
```

### Updating the consumer to use transactional messaging

To use transactional messaging, let's write a new method, `processEvent`, which will be called by our consumer. This event takes a database connection and an event, and writes the event to the `WEATHER_EVENT_DV` JSON Relational Duality View.

```java
private static void processEvent(Connection conn, JSONB jsonb, byte[] event) throws SQLException, IOException {
    String val = jsonb.fromOSON(event, WeatherEvent.class)
            .toString();
    System.out.println("[CONSUMER] Deserialized: " + val);
    final String sql = "INSERT INTO  WEATHER_EVENT_DV (data) VALUES (?)";
    try (PreparedStatement ps = conn.prepareStatement(sql)) {
        ps.setObject(1, event, OracleTypes.JSON);
        ps.executeUpdate();
    }
}
```

We then update our consumer to use the `processEvent` method. Note the handling of a `SQLException` - this is where we could implement any rollback or compensation logic should the database operation fail.

```java
private static Future<?> startConsumer() {
    JSONB jsonb = JSONB.createDefault();
    return EXECUTOR.submit(() -> {
        Connection conn = null;
        int consumedMessages = 0;
        try (Consumer<String, byte[]> consumer = createConsumer(connectionProperties())) {
            conn = ((KafkaConsumer<?, ?>) consumer).getDBConnection();
            consumer.subscribe(List.of(TOPIC_NAME));
            while (consumedMessages < TOTAL_RECORDS) {
                ConsumerRecords<String, byte[]> records = consumer.poll(Duration.ofSeconds(3));
                for (ConsumerRecord<String, byte[]> record : records) {
                    processEvent(conn, jsonb, record.value());
                }
                consumer.commitSync();
                consumedMessages += records.count();
            }
        } catch (IOException e) {
            System.out.println("[CONSUMER] Deserialization error: " + e.getMessage());
        } catch (SQLException e) {
            // Handle rollback / error handling
            System.out.println("[CONSUMER] SQL error: " + e.getMessage());
        }
        System.out.println("[CONSUMER] Committed all messages");
    });
}
```

When running the app, you should see the following:

```bash
[ADMIN] Topic already exists
[MAIN] Started consumer
[MAIN] Started producer
[PRODUCER] Serialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-03T06:00, temperature=18.2, humidity_percent=81.0, uv_index=0.0}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-03T08:00, temperature=21.7, humidity_percent=70.3, uv_index=2.5}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=2}, timestamp=2025-06-03T10:00, temperature=25.4, humidity_percent=62.8, uv_index=4.9}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=2}, timestamp=2025-06-03T12:00, temperature=28.6, humidity_percent=51.2, uv_index=7.3}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=3}, timestamp=2025-06-03T14:00, temperature=31.6, humidity_percent=40.5, uv_index=10.5}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=3}, timestamp=2025-06-03T16:00, temperature=30.1, humidity_percent=45.1, uv_index=9.0}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-03T18:00, temperature=27.0, humidity_percent=57.0, uv_index=3.8}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=2}, timestamp=2025-06-03T20:00, temperature=23.5, humidity_percent=63.3, uv_index=0.9}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=3}, timestamp=2025-06-03T22:00, temperature=20.8, humidity_percent=69.1, uv_index=0.0}
[PRODUCER] Serialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-04T00:00, temperature=18.6, humidity_percent=74.8, uv_index=0.0}
[PRODUCER] Produced all messages
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-03T06:00, temperature=18.2, humidity_percent=81.0, uv_index=0.0}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-03T08:00, temperature=21.7, humidity_percent=70.3, uv_index=2.5}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=2}, timestamp=2025-06-03T10:00, temperature=25.4, humidity_percent=62.8, uv_index=4.9}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=2}, timestamp=2025-06-03T12:00, temperature=28.6, humidity_percent=51.2, uv_index=7.3}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=3}, timestamp=2025-06-03T14:00, temperature=31.6, humidity_percent=40.5, uv_index=10.5}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=3}, timestamp=2025-06-03T16:00, temperature=30.1, humidity_percent=45.1, uv_index=9.0}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-03T18:00, temperature=27.0, humidity_percent=57.0, uv_index=3.8}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=2}, timestamp=2025-06-03T20:00, temperature=23.5, humidity_percent=63.3, uv_index=0.9}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=3}, timestamp=2025-06-03T22:00, temperature=20.8, humidity_percent=69.1, uv_index=0.0}
[CONSUMER] Deserialized: WeatherEvent{station=Station{id=1}, timestamp=2025-06-04T00:00, temperature=18.6, humidity_percent=74.8, uv_index=0.0}
[CONSUMER] Committed all messages
[MAIN] Done!
```

#### View weather events from JSON Duality View

```sql
select json_serialize(w.data pretty) as events
from weather_event_dv w;
```

### Cleanup

#### Truncate weather events

```sql
truncate table weather_event;
```

#### Cleanup all tables/views

```sql
drop view weather_event_dv;
drop table weather_event;
drop table weather_station;
```